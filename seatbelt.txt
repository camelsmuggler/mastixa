<#
.SYNOPSIS
    User-level comprehensive system audit collector (Seatbelt-like)
.DESCRIPTION
    Performs many enumerations (AMSI providers, AV via WMI, AppLocker, ARP table, audit policies, cert stores, network, processes, event logs, etc.)
    Writes results to a text log and JSON file in the current directory.
.NOTES
    Run as a normal user. Some checks require elevation; those will be attempted and errors will be recorded rather than stopping the run.
#>

# -------------------------
# Config / helpers
# -------------------------
$ScriptStart = Get-Date
$OutDir = Get-Location
$ts = $ScriptStart.ToString('yyyyMMdd-HHmmss')
$LogFile = Join-Path $OutDir "system-audit-$ts.log"
$JsonFile = Join-Path $OutDir "system-audit-$ts.json"

# Master result object
$Results = [ordered]@{
    Metadata = [ordered]@{
        CollectedAt = $ScriptStart
        Hostname = $env:COMPUTERNAME
        User = $env:USERNAME
        IsElevated = ([Security.Principal.WindowsIdentity]::GetCurrent()).Groups -match 'S-1-5-32-544' -or ([bool](net session 2>$null))
        PowerShellVersion = $PSVersionTable.PSVersion.ToString()
    }
    RequestsPerformed = 0
    Checks = [ordered]@{}
}

# Small helper to log lines to both console and file
function LogLine {
    param([string]$s)
    $s2 = "$(Get-Date -Format o) - $s"
    $s2 | Tee-Object -FilePath $LogFile -Append
}

# Increment request counter
function Inc-Request {
    $Results.RequestsPerformed++
}

# Safe runner wrapper
function Run-Safe {
    param([string]$Name, [ScriptBlock]$Block)
    LogLine "=== START: $Name ==="
    Inc-Request
    try {
        $res = & $Block
        $Results.Checks[$Name] = @{
            Success = $true
            Data = $res
            Error = $null
        }
        LogLine "=> $Name completed (Success)"
    } catch {
        $Results.Checks[$Name] = @{
            Success = $false
            Data = $null
            Error = $_.Exception.Message
        }
        LogLine "=> $Name failed: $($_.Exception.Message)"
    }
    LogLine "=== END: $Name ===`n"
}

# Helper: read registry value safely
function Get-RegistryValue {
    param($Hive, $Path, $Name)
    try {
        $key = Join-Path $Hive $Path
        $v = Get-ItemProperty -Path $key -Name $Name -ErrorAction Stop
        return $v.$Name
    } catch {
        return $null
    }
}

# Helper: return event log entries with timefilter
function Get-EventsRange {
    param($LogName, $IdList, $DaysBack=10)
    $start = (Get-Date).AddDays(-1 * [int]$DaysBack)
    try {
        Get-WinEvent -FilterHashtable @{LogName=$LogName; Id=$IdList; StartTime=$start} -ErrorAction Stop
    } catch {
        # fallback to Get-EventLog if WinEvent not available
        try { Get-EventLog -LogName $LogName | Where-Object { $_.EventID -in $IdList -and $_.TimeGenerated -ge $start } } catch { @() }
    }
}

# -------------------------
# Checks
# -------------------------

# AMSI Providers - registry lookup (best-effort)
Run-Safe "AMSIProviders" {
    $provPath = "HKLM:\SOFTWARE\Microsoft\AMSI\Providers"
    if (Test-Path $provPath) {
        Get-ChildItem $provPath | ForEach-Object {
            [ordered]@{
                Name = $_.PSChildName
                Properties = (Get-ItemProperty -Path $_.PSPath | Select-Object -Property * -ExcludeProperty PS* | ForEach-Object {[ordered]$PSItem.PSObject.Properties | ForEach-Object { @{($_.Name) = $_.Value} }})
            }
        }
    } else {
        "No AMSI Providers registry key found (or path inaccessible)."
    }
}

# AntiVirus - SecurityCenter2 WMI (best-effort)
Run-Safe "AntiVirus" {
    try {
        Get-CimInstance -Namespace root\SecurityCenter2 -ClassName AntiVirusProduct -ErrorAction Stop |
            Select-Object displayName,productState,instanceGuid,pathToSignedProductExe
    } catch {
        # older systems or restricted access
        try { Get-WmiObject -Namespace root\SecurityCenter2 -Class AntiVirusProduct -ErrorAction Stop | Select-Object displayName,productState,instanceGuid } catch { "Unable to enumerate AntiVirusProduct via WMI/CIM: $($_.Exception.Message)" }
    }
}

# AppLocker - try Get-AppLockerPolicy (may not exist / requires RSOP)
Run-Safe "AppLocker" {
    try {
        if (Get-Command Get-AppLockerPolicy -ErrorAction SilentlyContinue) {
            # Effective policy for local computer
            Get-AppLockerPolicy -Effective | Select-Object -Property RuleCollections
        } else {
            "Get-AppLockerPolicy not available on this host."
        }
    } catch {
        "Error enumerating AppLocker: $($_.Exception.Message)"
    }
}

# ARP Table (arp -a) + adapter info
Run-Safe "ARPTable" {
    $arp = (arp -a) -join "`n"
    $adapters = Get-NetIPConfiguration | Select-Object InterfaceAlias, IPv4Address, IPv6Address, InterfaceIndex, DNSServers
    [ordered]@{ ARP = $arp; Adapters = $adapters }
}

# AuditPolicies - classic and advanced
Run-Safe "AuditPolicies" {
    $classic = secedit /export /cfg "$env:TEMP\secpol_$ts.txt" 2>$null
    $classicData = if (Test-Path "$env:TEMP\secpol_$ts.txt") { Get-Content "$env:TEMP\secpol_$ts.txt" } else { "secedit export failed or unavailable" }
    # advanced
    try {
        $adv = Get-AuditPolicy -Category * -ErrorAction Stop
    } catch {
        $adv = "Get-AuditPolicy not available or access denied: $($_.Exception.Message)"
    }
    [ordered]@{ Classic = $classicData; Advanced = $adv }
}

# AuditPolicyRegistry - read known registry locations
Run-Safe "AuditPolicyRegistry" {
    $keys = @(
        "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa",
        "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Audit"
    )
    $out = @{}
    foreach ($k in $keys) {
        if (Test-Path $k) { $out[$k] = Get-ItemProperty -Path $k -ErrorAction SilentlyContinue } else { $out[$k] = "Missing" }
    }
    $out
}

# AutoRuns - common Run keys, scheduled tasks, services with Auto start
Run-Safe "AutoRuns" {
    $runKeys = @(
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce",
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
    )
    $runs = @{}
    foreach ($k in $runKeys) {
        if (Test-Path $k) { $runs[$k] = Get-ItemProperty -Path $k -ErrorAction SilentlyContinue | Select-Object * } else { $runs[$k] = $null }
    }
    # Scheduled tasks (names and last run info)
    try {
        $tasks = schtasks /Query /FO CSV /V 2>$null | ConvertFrom-Csv
    } catch {
        $tasks = "Unable to enumerate scheduled tasks: $($_.Exception.Message)"
    }
    # Services auto-start
    $services = Get-Service | Where-Object { $_.StartType -eq 'Automatic' } | Select-Object Name,DisplayName,Status
    [ordered]@{ RegistryRunKeys = $runs; ScheduledTasks = $tasks; AutoServices = $services }
}

# Certificates (user and machine personal)
Run-Safe "Certificates" {
    $cu = Get-ChildItem -Path Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Select-Object Subject,Thumbprint,NotAfter,Issuer
    $lm = Get-ChildItem -Path Cert:\LocalMachine\My -ErrorAction SilentlyContinue | Select-Object Subject,Thumbprint,NotAfter,Issuer
    [ordered]@{ CurrentUser = $cu; LocalMachine = $lm }
}

# CertificateThumbprints
Run-Safe "CertificateThumbprints" {
    $stores = @("LocalMachine","CurrentUser")
    $out = @{}
    foreach ($s in $stores) {
        try {
            $path = "Cert:\$s\My"
            $out[$s] = Get-ChildItem -Path $path -ErrorAction Stop | Select-Object Subject,Thumbprint
        } catch { $out[$s] = "Unable to read $path: $($_.Exception.Message)" }
    }
    $out
}

# CredGuard - best-effort: check LSA-related flags and Device Guard state
Run-Safe "CredGuard" {
    $cg = @{
        LsaCfgFlags = Get-RegistryValue -Hive HKLM -Path "SYSTEM\CurrentControlSet\Control\Lsa" -Name "LsaCfgFlags"
        LsaCfgFlagsDetails = (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -ErrorAction SilentlyContinue)
    }
    # try Device Guard / Credential Guard querying
    try {
        $dg = Get-CimInstance -Namespace root\Microsoft\Windows\DeviceGuard -ClassName Win32_DeviceGuard -ErrorAction Stop
        $cg.DeviceGuard = $dg
    } catch {
        $cg.DeviceGuard = "Unavailable or no DeviceGuard CIM class on this host."
    }
    $cg
}

# DNSCache via WMI / Get-DnsClientCache
Run-Safe "DNSCache" {
    try {
        if (Get-Command Get-DnsClientCache -ErrorAction SilentlyContinue) {
            Get-DnsClientCache
        } else {
            # fallback: query DNS client service cache not easily accessible -> use ipconfig /displaydns
            ipconfig /displaydns 2>$null
        }
    } catch { "DNSCache enumeration failed: $($_.Exception.Message)" }
}

# DotNet versions
Run-Safe "DotNet" {
    # check registry for installed frameworks and runtime
    $net = @{}
    try {
        $fw = Get-ChildItem "HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP" -ErrorAction SilentlyContinue -Recurse |
              Get-ItemProperty -Name Version,Release -ErrorAction SilentlyContinue |
              Select-Object PSPath,Version,Release
        $net.RegistryFramework = $fw
    } catch { $net.RegistryFramework = "Error fetching .NET registry info: $($_.Exception.Message)" }
    # .NET Core / runtimes
    try {
        $coreRuntimes = & dotnet --list-runtimes 2>$null
        $net.DotnetCLI = if ($LASTEXITCODE -eq 0) { $coreRuntimes } else { "dotnet CLI not present or inaccessible" }
    } catch { $net.DotnetCLI = "dotnet CLI not present or inaccessible" }
    $net
}

# EnvironmentPath - PATH folders and SDDL info where applicable
Run-Safe "EnvironmentPath" {
    $pathUser = [Environment]::GetEnvironmentVariable("PATH", "User")
    $pathMachine = [Environment]::GetEnvironmentVariable("PATH", "Machine")
    [ordered]@{
        UserPath = $pathUser -split ';'
        MachinePath = $pathMachine -split ';'
        SDDL = "SDDL info not broadly available per PATH entry; permissions can be fetched per folder in next step"
    }
}

# EnvironmentVariables - current user env vars
Run-Safe "EnvironmentVariables" {
    Get-ChildItem Env: | Sort-Object Name | Select-Object Name,Value
}

# Hotfixes - WMI
Run-Safe "Hotfixes" {
    try { Get-CimInstance -ClassName Win32_QuickFixEngineering -ErrorAction Stop | Select-Object HotFixID,InstalledOn,Description } catch { "Unable to enumerate hotfixes via WMI/CIM: $($_.Exception.Message)" }
}

# InterestingProcesses - defensive products and admin tools heuristic
Run-Safe "InterestingProcesses" {
    $proc = Get-Process -ErrorAction SilentlyContinue | Select-Object Id,ProcessName,Path -ErrorAction SilentlyContinue
    # heuristics - non-Microsoft company names, and names often associated with security/admin tools
    $interesting = $proc | Where-Object { ($_.Path -and (try { (Get-Item $_.Path).VersionInfo.CompanyName } catch { '' }) -notlike '*Microsoft*') -or ($_.ProcessName -match 'procmon|wireshark|fiddler|impacket|rundll32|psexec|mimikatz|ngrok|powershell') }
    $interesting
}

# InternetSettings - proxy configs and IE/WinINET settings
Run-Safe "InternetSettings" {
    try {
        $ie = Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings" -ErrorAction SilentlyContinue
        [ordered]@{ InternetSettings = $ie }
    } catch { "Unable to read Internet Settings: $($_.Exception.Message)" }
}

# LAPS settings (if installed) - check GPO / registry local policy
Run-Safe "LAPS" {
    $laps = @{
        Installed = (Get-Module -ListAvailable -Name LAPS | Select-Object -ExpandProperty Name) -ne $null
        GPOSettings = (Get-ItemProperty -Path "HKLM:\Software\Policies\Microsoft Services\LAPS" -ErrorAction SilentlyContinue)
        LocalReg = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\LAPS" -ErrorAction SilentlyContinue)
    }
    $laps
}

# LastShutdown - registry
Run-Safe "LastShutdown" {
    try {
        $lm = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Windows" -Name "ShutdownTime" -ErrorAction SilentlyContinue
        if ($lm -and $lm.ShutdownTime) {
            # ShutdownTime stored as FILETIME in registry (on some systems); fallback to System event 6006 if not
            $lm.ShutdownTime
        } else {
            # fallback to system event 6006 (EventLog stop) or 6008
            $ev = Get-EventsRange -LogName System -IdList @(6006,6008) -DaysBack 30
            $ev | Select-Object TimeCreated, Id, Message -First 5
        }
    } catch { "Unable to determine last shutdown: $($_.Exception.Message)" }
}

# LocalGPOs - export local group policy if available (secedit)
Run-Safe "LocalGPOs" {
    try {
        secedit /export /cfg "$env:TEMP\localgpo_$ts.txt" 2>$null
        if (Test-Path "$env:TEMP\localgpo_$ts.txt") { Get-Content "$env:TEMP\localgpo_$ts.txt" } else { "secedit export failed or not available" }
    } catch { "Error exporting local GPOs: $($_.Exception.Message)" }
}

# LocalGroups - non-empty local groups
Run-Safe "LocalGroups" {
    try {
        Get-LocalGroup -ErrorAction Stop | ForEach-Object {
            $members = (Get-LocalGroupMember -Group $_.Name -ErrorAction SilentlyContinue) 
            if ($members) { [ordered]@{Group=$_.Name; Members=$members}} 
        }
    } catch {
        # fallback via ADSI
        $lg = [ADSI]"WinNT://$env:COMPUTERNAME"
        $groups = $lg.Children | Where-Object { $_.SchemaClassName -eq 'Group' } | ForEach-Object {
            $members = @()
            try { $members = $_.Invoke("Members") | ForEach-Object { $_.GetType().InvokeMember("Name",'GetProperty',$null,$_,$null) } } catch {}
            if ($members.Count -gt 0) { [ordered]@{ Group = $_.Name; Members = $members } }
        }
        $groups
    }
}

# LocalUsers - active/disabled and pwd last set
Run-Safe "LocalUsers" {
    try {
        Get-LocalUser -ErrorAction Stop | Select-Object Name,Enabled,LastPasswordSet
    } catch {
        # ADSI fallback
        $users = [ADSI]"WinNT://$env:COMPUTERNAME"
        $users.Children | Where-Object { $_.SchemaClassName -eq 'User' } | ForEach-Object {
            [ordered]@{ Name = $_.Name; Disabled = $_.AccountDisabled; LastPasswordSet = $_.PasswordAge }
        }
    }
}

# LogonSessions - Event ID 4624 (last X days default 10)
Run-Safe "LogonSessions" {
    param($DaysBack = 10)
    Get-EventsRange -LogName Security -IdList @(4624) -DaysBack $DaysBack | Select-Object TimeCreated, Id, @{n='Account';e={($_.Properties | Where-Object {$_.Id -eq 5} | ForEach-Object {$_.Value}) -join ','}}, Message -First 200
}

# LSASettings
Run-Safe "LSASettings" {
    Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -ErrorAction SilentlyContinue
}

# McAfeeConfigs - search for typical McAfee config files
Run-Safe "McAfeeConfigs" {
    $paths = @(
        "C:\ProgramData\McAfee",
        "C:\Program Files\McAfee",
        "$env:ProgramFiles\McAfee"
    ) | Where-Object { Test-Path $_ }
    $configs = @()
    foreach ($p in $paths) { $configs += Get-ChildItem -Path $p -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -match 'SiteList|Config|mcinfo|xml' } | Select-Object FullName, LastWriteTime -First 50 }
    $configs
}

# NamedPipes - list via Get-ChildItem on \\.\pipe\
Run-Safe "NamedPipes" {
    try {
        $pipes = Get-ChildItem -Path '\\.\pipe\' -ErrorAction Stop | Select-Object Name
        $pipes
    } catch { "Unable to enumerate named pipes: $($_.Exception.Message)" }
}

# NetworkProfiles
Run-Safe "NetworkProfiles" {
    try { Get-NetConnectionProfile -ErrorAction Stop | Select-Object Name,InterfaceAlias,NetworkCategory } catch { "Unable to fetch network profiles: $($_.Exception.Message)" }
}

# NetworkShares via WMI
Run-Safe "NetworkShares" {
    try { Get-CimInstance -ClassName Win32_Share -ErrorAction Stop | Select-Object Name,Path,Description } catch { "Unable to enumerate network shares via WMI/CIM: $($_.Exception.Message)" }
}

# NTLMSettings - registry areas for LANMAN and NTLM
Run-Safe "NTLMSettings" {
    $keys = @(
        "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0",
        "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa"
    )
    $out = @{}
    foreach ($k in $keys) {
        if (Test-Path $k) { $out[$k] = Get-ItemProperty -Path $k -ErrorAction SilentlyContinue } else { $out[$k] = "Missing" }
    }
    $out
}

# OptionalFeatures - list Windows optional features (Get-WindowsOptionalFeature may require admin)
Run-Safe "OptionalFeatures" {
    try {
        if (Get-Command Get-WindowsOptionalFeature -ErrorAction SilentlyContinue) {
            Get-WindowsOptionalFeature -Online
        } else { "Get-WindowsOptionalFeature not available in this environment." }
    } catch { "Unable to enumerate optional features: $($_.Exception.Message)" }
}

# OSInfo
Run-Safe "OSInfo" {
    Get-CimInstance -ClassName CIM_OperatingSystem | Select-Object Caption,Version,OSArchitecture,BuildNumber
}

# PoweredOnEvents - system event IDs 1,12,13,42,6008 default 7 days
Run-Safe "PoweredOnEvents" {
    Get-EventsRange -LogName System -IdList @(1,12,13,42,6008) -DaysBack 7 | Select-Object TimeCreated, Id, Message -First 200
}

# PowerShell - versions and execution policy and transcription settings
Run-Safe "PowerShell" {
    [ordered]@{
        PSVersion = $PSVersionTable
        ExecutionPolicy = Get-ExecutionPolicy -List
        Transcription = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" -ErrorAction SilentlyContinue)
        ModulePaths = $env:PSModulePath -split ';'
    }
}

# Processes - running processes with file info company names not containing Microsoft
Run-Safe "Processes" {
    Get-Process -ErrorAction SilentlyContinue | ForEach-Object {
        $p = $_
        $company = $null
        try { $company = (Get-Item $p.Path -ErrorAction SilentlyContinue).VersionInfo.CompanyName } catch {}
        [ordered]@{ Id=$p.Id; Name=$p.ProcessName; Path=$p.Path; Company=$company }
    }
}

# PSSessionSettings - registry
Run-Safe "PSSessionSettings" {
    Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WSMAN" -ErrorAction SilentlyContinue
}

# RDPSessions - current incoming RDP sessions via quser or qwinsta
Run-Safe "RDPSessions" {
    try {
        qwinsta 2>$null | Out-String
    } catch { "Unable to enumerate RDP sessions (qwinsta unavailable)" }
}

# RDPsettings - server and client settings via registry
Run-Safe "RDPsettings" {
    $server = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server" -ErrorAction SilentlyContinue
    $client = Get-ItemProperty -Path "HKCU:\Software\Microsoft\Terminal Server Client" -ErrorAction SilentlyContinue
    [ordered]@{ Server = $server; Client = $client }
}

# SCCM - check WMI namespace SMS for client settings
Run-Safe "SCCM" {
    try { Get-WmiObject -Namespace "root\ccm" -List -ErrorAction Stop | Select-Object -First 20 } catch { "SCCM WMI namespace not accessible or SCCM not present: $($_.Exception.Message)" }
}

# Services - non-Microsoft services (file company not Microsoft)
Run-Safe "Services" {
    Get-WmiObject -Class Win32_Service -ErrorAction SilentlyContinue | ForEach-Object {
        $svc = $_
        $company = $null
        try { $company = (Get-Item $svc.PathName -ErrorAction SilentlyContinue).VersionInfo.CompanyName } catch {}
        [ordered]@{ Name = $svc.Name; DisplayName = $svc.DisplayName; PathName = $svc.PathName; Company = $company; StartMode = $svc.StartMode; State = $svc.State }
    } | Where-Object { ($_.Company -and $_.Company -notlike "*Microsoft*") -or ($_.PathName -and $_.PathName -notmatch 'Windows\\System32') }
}

# Sysmon - check Sysmon config in registry
Run-Safe "Sysmon" {
    try {
        $cfg = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Sysmon" -ErrorAction SilentlyContinue
        if ($cfg) { $cfg } else { "Sysmon registry key not present" }
    } catch { "Error reading Sysmon registry: $($_.Exception.Message)" }
}

# TcpConnections
Run-Safe "TcpConnections" {
    try { Get-NetTCPConnection -ErrorAction Stop | Select-Object LocalAddress,LocalPort,RemoteAddress,RemotePort,State,OwningProcess } catch { "Get-NetTCPConnection not available or access denied: $($_.Exception.Message)" }
}

# TokenPrivileges - enabled token privileges for current process
Run-Safe "TokenPrivileges" {
    try {
        $nt = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $nt.Token
        # Quick list of claims/privileges not trivial in pure PS; provide what we can
        [ordered]@{ Name = $nt.Name; AuthenticationType = $nt.AuthenticationType; IsAuthenticated = $nt.IsAuthenticated }
    } catch { "Unable to fetch TokenPrivileges: $($_.Exception.Message)" }
}

# UAC - registry policies
Run-Safe "UAC" {
    Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -ErrorAction SilentlyContinue
}

# UdpConnections
Run-Safe "UdpConnections" {
    try { Get-NetUDPEndpoint -ErrorAction Stop | Select-Object LocalAddress,LocalPort,OwingProcess } catch { "Get-NetUDPEndpoint not available or access denied: $($_.Exception.Message)" }
}

# UserRightAssignments - using secedit / exported template perhaps
Run-Safe "UserRightAssignments" {
    try {
        secedit /export /cfg "$env:TEMP\UserRights_$ts.inf" 2>$null
        if (Test-Path "$env:TEMP\UserRights_$ts.inf") { Get-Content "$env:TEMP\UserRights_$ts.inf" | Where-Object { $_ -match 'Se' } } else { "secedit export failed or not available" }
    } catch { "Unable to enumerate user rights: $($_.Exception.Message)" }
}

# WifiProfile - list saved wireless profiles (may require admin for all users; here current user)
Run-Safe "WifiProfile" {
    try { netsh wlan show profiles 2>$null } catch { "Unable to query wifi profiles: $($_.Exception.Message)" }
}

# WindowsAutoLogon - registry autologon
Run-Safe "WindowsAutoLogon" {
    Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -ErrorAction SilentlyContinue
}

# WindowsDefender - local defender settings & exclusions
Run-Safe "WindowsDefender" {
    try {
        $wd = @{
            AMPolicy = Get-MpPreference -ErrorAction SilentlyContinue
            Exclusions = (Get-MpPreference -ErrorAction SilentlyContinue).ExclusionPath
        }
        $wd
    } catch { "Windows Defender cmdlets not available or access denied: $($_.Exception.Message)" }
}

# WindowsEventForwarding - registry settings
Run-Safe "WindowsEventForwarding" {
    Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Subscription" -ErrorAction SilentlyContinue
}

# WindowsFirewall - non-standard rules (filter by rules not default)
Run-Safe "WindowsFirewall" {
    try {
        $rules = Get-NetFirewallRule -ErrorAction Stop | Select-Object Name,DisplayName,Direction,Action,Enabled,Profile
        $rules
    } catch { "Unable to enumerate firewall rules: $($_.Exception.Message)" }
}

# WMIEventConsumer
Run-Safe "WMIEventConsumer" {
    try { Get-WmiObject -Namespace root\subscription -Class __EventConsumer -ErrorAction Stop | Select-Object Name,Path } catch { "Unable to enumerate WMI Event Consumers: $($_.Exception.Message)" }
}

# WMIEventFilter
Run-Safe "WMIEventFilter" {
    try { Get-WmiObject -Namespace root\subscription -Class __EventFilter -ErrorAction Stop | Select-Object Name,Query } catch { "Unable to enumerate WMI Event Filters: $($_.Exception.Message)" }
}

# WMIFilterBinding
Run-Safe "WMIFilterBinding" {
    try { Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding -ErrorAction Stop | Select-Object * } catch { "Unable to enumerate WMI Filter to Consumer Bindings: $($_.Exception.Message)" }
}

# WSUS settings - registry locations and services
Run-Safe "WSUS" {
    $wsus = Get-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows\WindowsUpdate" -ErrorAction SilentlyContinue
    $wsus
}

# -------------------------
# 'user' group checks (current user scoped)
# -------------------------
# Certificates (user & machine handled above) - add user-specific entries
Run-Safe "user.Certificates" {
    Get-ChildItem -Path Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Select Subject,Thumbprint,NotAfter
}

Run-Safe "user.CertificateThumbprints" {
    Get-ChildItem -Path Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Select-Object Thumbprint,Subject
}

Run-Safe "user.ChromiumPresence" {
    $targets = @(
        "$env:LOCALAPPDATA\Google\Chrome\User Data",
        "$env:LOCALAPPDATA\Microsoft\Edge\User Data",
        "$env:LOCALAPPDATA\BraveSoftware\Brave-Browser\User Data",
        "$env:APPDATA\Opera Software"
    )
    $found = $targets | ForEach-Object { @{Path=$_; Exists = Test-Path $_ } }
    $found
}

Run-Safe "user.CloudCredentials" {
    $paths = @(
        "$env:USERPROFILE\.aws",
        "$env:USERPROFILE\AppData\Roaming\gcloud",
        "$env:USERPROFILE\.azure"
    )
    $out = @{}
    foreach ($p in $paths) { $out[$p] = Test-Path $p }
    $out
}

Run-Safe "user.CredEnum" {
    try {
        Add-Type -AssemblyName System.Security
        $creds = @()
        $credPtr = [IntPtr]::Zero
        # Use native CredEnumerate via P/Invoke is complex; for safety we will attempt to call cmdkey to list credentials
        $cmd = cmdkey /list 2>$null
        if ($cmd) { $cmd } else { "cmdkey not returning entries or access denied" }
    } catch { "CredEnumerate not implemented; returning cmdkey output: $($_.Exception.Message)" }
}

Run-Safe "user.dir" {
    param($Custom = $null)
    $targets = if ($Custom) { $Custom } else { @("$env:USERPROFILE\Downloads","$env:USERPROFILE\Documents","$env:USERPROFILE\Desktop") }
    $listing = @{}
    foreach ($t in $targets) {
        if (Test-Path $t) { $listing[$t] = Get-ChildItem -Path $t -Recurse -File -ErrorAction SilentlyContinue | Select-Object FullName,Length,LastWriteTime -First 200 } else { $listing[$t] = "Missing" }
    }
    $listing
}

Run-Safe "user.DpapiMasterKeys" {
    $dir = "$env:APPDATA\Microsoft\Protect"
    if (Test-Path $dir) { Get-ChildItem -Path $dir -Recurse -ErrorAction SilentlyContinue | Select-Object FullName,Length,LastWriteTime } else { "DPAPI master keys folder not present for user" }
}

Run-Safe "user.ExplorerMRUs" {
    # MRUs are stored across registry and files; provide basic typed-run MRU via registry
    try {
        $runMRU = Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" -ErrorAction SilentlyContinue
        $runMRU
    } catch { "Unable to read Explorer MRUs: $($_.Exception.Message)" }
}

Run-Safe "user.ExplorerRunCommands" {
    Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSaveMRU" -ErrorAction SilentlyContinue
}

Run-Safe "user.FileZilla" {
    $p = "$env:APPDATA\FileZilla"
    if (Test-Path $p) { Get-ChildItem -Path $p -Recurse -ErrorAction SilentlyContinue | Select-Object FullName -First 50 } else { "FileZilla config not found" }
}

Run-Safe "user.FirefoxPresence" {
    $paths = @("$env:APPDATA\Mozilla\Firefox","$env:LOCALAPPDATA\Mozilla\Firefox")
    $paths | ForEach-Object { @{Path=$_; Exists = Test-Path $_} }
}

Run-Safe "user.IdleTime" {
    Add-Type @"
using System;
using System.Runtime.InteropServices;
public static class Idle {
    [DllImport("user32.dll")]
    public static extern bool GetLastInputInfo(ref LASTINPUTINFO plii);
    public struct LASTINPUTINFO { public uint cbSize; public uint dwTime; }
}
"@
    $li = New-Object Idle+LASTINPUTINFO
    $li.cbSize = [System.Runtime.InteropServices.Marshal]::SizeOf($li)
    [Idle]::GetLastInputInfo([ref]$li) | Out-Null
    $idleMs = [Environment]::TickCount - $li.dwTime
    [ordered]@{ IdleSeconds = [math]::Round($idleMs/1000,2) }
}

Run-Safe "user.IEFavorites" {
    $fav = "$env:USERPROFILE\Favorites"
    if (Test-Path $fav) { Get-ChildItem -Path $fav -Recurse -ErrorAction SilentlyContinue | Select-Object FullName -First 200 } else { "IE Favorites folder not present" }
}

Run-Safe "user.IEUrls" {
    # Typed URLs stored in registry typed URLs
    Get-ItemProperty -Path "HKCU:\Software\Microsoft\Internet Explorer\TypedURLs" -ErrorAction SilentlyContinue
}

Run-Safe "user.MappedDrives" {
    try { Get-PSDrive -PSProvider FileSystem | Where-Object { $_.DisplayRoot -and $_.DisplayRoot -match '\\' } } catch { "Unable to get mapped drives: $($_.Exception.Message)" }
}

Run-Safe "user.OfficeMRUs" {
    # Office MRUs are scattered; list common locations
    $officeMRUs = @(
        "$env:APPDATA\Microsoft\Office\Recent",
        "$env:LOCALAPPDATA\Microsoft\Office\Recent"
    ) | ForEach-Object { if (Test-Path $_) { Get-ChildItem -Path $_ -Recurse -ErrorAction SilentlyContinue } else { "$_ Missing" } }
    $officeMRUs
}

Run-Safe "user.PowerShellHistory" {
    $histories = @()
    $users = @($env:USERNAME)
    foreach ($u in $users) {
        $profilePath = "$env:USERPROFILE\Documents\WindowsPowerShell\PSReadLineHistory.txt"
        if (Test-Path $profilePath) { $histories += @{ User = $u; Path = $profilePath; Entries = Get-Content $profilePath -ErrorAction SilentlyContinue | Select-Object -Last 200 } } else { $histories += @{User=$u; Path = $profilePath; Entries = "Missing"} }
    }
    $histories
}

Run-Safe "user.PuttyHostKeys" {
    $p = "$env:APPDATA\PuTTY\sshhostkeys"
    if (Test-Path $p) { Get-Content $p -ErrorAction SilentlyContinue } else { "Putty host keys not present" }
}

Run-Safe "user.PuttySessions" {
    $reg = "HKCU:\Software\SimonTatham\PuTTY\Sessions"
    if (Test-Path $reg) { Get-ChildItem $reg | ForEach-Object { @{ Session = $_.PSChildName; Props = (Get-ItemProperty -Path $_.PSPath) } } } else { "PuTTY sessions registry not present" }
}

Run-Safe "user.RDPSavedConnections" {
    Get-ItemProperty -Path "HKCU:\Software\Microsoft\Terminal Server Client\Default" -ErrorAction SilentlyContinue
}

Run-Safe "user.SecPackageCreds" {
    "Enumerating security package cached creds typically requires elevated/native API; returning token groups/user info"
    try { [System.Security.Principal.WindowsIdentity]::GetCurrent().Groups } catch { $null }
}

Run-Safe "user.SlackDownloads" {
    $p = "$env:APPDATA\Slack"
    if (Test-Path $p) { Get-ChildItem -Path $p -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -match 'slack-downloads' } | Select-Object FullName -First 20 } else { "Slack not present" }
}

Run-Safe "user.SlackPresence" {
    Test-Path "$env:APPDATA\Slack"
}

Run-Safe "user.SlackWorkspaces" {
    $f = "$env:APPDATA\Slack\local-storage"
    if (Test-Path $f) { Get-ChildItem -Path $f -Recurse -ErrorAction SilentlyContinue | Select-Object FullName -First 50 } else { "Slack local-storage not present" }
}

Run-Safe "user.SuperPutty" {
    $p = "$env:APPDATA\SuperPuTTY"
    if (Test-Path $p) { Get-ChildItem -Path $p -Recurse -ErrorAction SilentlyContinue | Select-Object FullName -First 50 } else { "SuperPutty not present" }
}

Run-Safe "user.TokenGroups" {
    try {
        $id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $id.Groups | ForEach-Object { $_.Value }
    } catch { "Unable to fetch token groups: $($_.Exception.Message)" }
}

Run-Safe "user.WindowsCredentialFiles" {
    $vaults = "$env:LOCALAPPDATA\Microsoft\Vault", "$env:APPDATA\Microsoft\Credentials"
    $out = @{}
    foreach ($v in $vaults) { $out[$v] = if (Test-Path $v) { Get-ChildItem -Path $v -Recurse -ErrorAction SilentlyContinue | Select-Object FullName -First 50 } else { "Missing" } }
    $out
}

Run-Safe "user.WindowsVault" {
    try {
        cmdkey /list 2>$null
    } catch { "cmdkey not available or access denied" }
}

# -------------------------
# misc group checks (selected)
# -------------------------
Run-Safe "misc.ChromiumBookmarks" {
    $paths = @("$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Bookmarks","$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Bookmarks")
    $paths | ForEach-Object { if (Test-Path $_) { @{ Path = $_; Content = Get-Content $_ -ErrorAction SilentlyContinue | Select-Object -First 200 } } else { "$_ Missing" } }
}

Run-Safe "misc.ChromiumHistory" {
    $histPaths = @("$env:LOCALAPPDATA\Google\Chrome\User Data\Default\History","$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\History") 
    $histPaths | ForEach-Object { if (Test-Path $_) { @{ Path = $_; Exists = $true } } else { @{ Path = $_; Exists = $false } } }
}

Run-Safe "misc.ExplicitLogonEvents" {
    Get-EventsRange -LogName Security -IdList @(4648) -DaysBack 7 | Select-Object TimeCreated, Message -First 200
}

Run-Safe "misc.FileInfo" {
    param($Files)
    if ($Files) { foreach ($f in $Files) { if (Test-Path $f) { Get-Item $f | Select-Object FullName,Length,LastWriteTime } else { "$f missing" } } } else { "No file argument provided" }
}

Run-Safe "misc.FirefoxHistory" {
    "Firefox history parsing requires sqlite access; indicating presence of places.sqlite if available."
    $ff = "$env:APPDATA\Mozilla\Firefox\Profiles"
    if (Test-Path $ff) { Get-ChildItem -Path $ff -Recurse -Filter places.sqlite -ErrorAction SilentlyContinue | Select-Object FullName } else { "Firefox profiles not present" }
}

Run-Safe "misc.InstalledProducts" {
    try {
        Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* -ErrorAction SilentlyContinue | Select-Object DisplayName,DisplayVersion,Publisher,InstallDate
    } catch { "Unable to enumerate installed products: $($_.Exception.Message)" }
}

Run-Safe "misc.InterestingFiles" {
    # heuristic search in user profile for "password","key","credential"
    $patterns = 'password','key','credential','secret'
    $found = @()
    foreach ($p in $patterns) {
        $found += Get-ChildItem -Path $env:USERPROFILE -Recurse -ErrorAction SilentlyContinue -Filter "*$p*" | Select-Object FullName -First 100
    }
    $found
}

Run-Safe "misc.LogonEvents" {
    Get-EventsRange -LogName Security -IdList @(4624) -DaysBack 10 | Select-Object TimeCreated,Message -First 200
}

Run-Safe "misc.LOLBAS" {
    # simple heuristic: search for known LOLBAS filenames in PATH
    $paths = ($env:PATH -split ';') | Where-Object { $_ -ne '' }
    $candidates = @('certutil.exe','bitsadmin.exe','regsvr32.exe','rundll32.exe','mshta.exe','wmic.exe','schtasks.exe')
    $found = @{}
    foreach ($p in $paths) {
        foreach ($c in $candidates) {
            $fp = Join-Path $p $c
            if (Test-Path $fp) { $found[$c] = $fp }
        }
    }
    $found
}

Run-Safe "misc.McAfeeSiteList" {
    $p = "$env:ProgramFiles\McAfee\SiteList.xml","C:\ProgramData\McAfee\SiteList.xml"
    $p | ForEach-Object { if (Test-Path $_) { Get-Content $_ -ErrorAction SilentlyContinue } else { "$_ Missing" } }
}

Run-Safe "misc.MicrosoftUpdates" {
    try { Get-WmiObject -Namespace "root\ccm\ClientSDK" -Class CCM_SoftwareDistributionStatus -ErrorAction SilentlyContinue | Select-Object -First 20 } catch { "Microsoft Update enumeration via COM/WMI limited on this host" }
}

Run-Safe "misc.OutlookDownloads" {
    $d = "$env:USERPROFILE\Downloads"
    if (Test-Path $d) { Get-ChildItem -Path $d -Include *.msg,*.pst,*.ost -Recurse -ErrorAction SilentlyContinue | Select-Object FullName -First 200 } else { "Downloads folder missing" }
}

Run-Safe "misc.PowerShellEvents" {
    Get-EventsRange -LogName Microsoft-Windows-PowerShell/Operational -IdList @(4104) -DaysBack 7 | Select-Object TimeCreated,Message -First 200
}

Run-Safe "misc.Printers" {
    try { Get-Printer -ErrorAction Stop } catch { "Printer enumeration not available" }
}

Run-Safe "misc.ProcessCreationEvents" {
    Get-EventsRange -LogName Security -IdList @(4688) -DaysBack 7 | Select-Object TimeCreated,Message -First 200
}

Run-Safe "misc.ProcessOwners" {
    Get-Process -IncludeUserName -ErrorAction SilentlyContinue | Select-Object Id,ProcessName,UserName -First 200
}

Run-Safe "misc.RecycleBin" {
    $rb = @()
    try {
        $shell = New-Object -ComObject Shell.Application
        $rbFolder = $shell.NameSpace(0xA)
        $rbFolder.Items() | ForEach-Object { $rb += @{Name = $_.Name; Path = $_.Path } }
        $rb
    } catch { "Recycle bin enumeration may be limited: $($_.Exception.Message)" }
}

Run-Safe "misc.reg" {
    param($Path = "HKLM:\Software", $Depth = 1, $Regex = $null)
    try {
        Get-ChildItem -Path $Path -Recurse -Depth $Depth -ErrorAction SilentlyContinue | Select-Object PSPath -First 200
    } catch { "Registry enumeration failed: $($_.Exception.Message)" }
}

Run-Safe "misc.RPCMappedEndpoints" {
    try { Get-WmiObject -Namespace "root\RPC" -List -ErrorAction SilentlyContinue | Select-Object -First 50 } catch { "Cannot enumerate RPC mapped endpoints on this host" }
}

Run-Safe "misc.ScheduledTasks" {
    try { schtasks /Query /FO CSV /V 2>$null | ConvertFrom-Csv } catch { "Cannot enumerate scheduled tasks" }
}

Run-Safe "misc.SearchIndex" {
    "Search index query requires Search API; returning message"
}

Run-Safe "misc.SecurityPackages" {
    try { Get-ChildItem 'HKLM:\System\CurrentControlSet\Control\SecurityProviders' -ErrorAction SilentlyContinue } catch { "Unable to enumerate security packages: $($_.Exception.Message)" }
}

Run-Safe "misc.SysmonEvents" {
    Get-EventsRange -LogName "Microsoft-Windows-Sysmon/Operational" -IdList @(1) -DaysBack 7 | Select-Object TimeCreated,Message -First 200
}

# -------------------------
# Finalize: write output
# -------------------------
$Results.Metadata.CompletedAt = Get-Date
$Results.Metadata.DurationSeconds = (Get-Date) - $ScriptStart

# Write JSON
try {
    $Results | ConvertTo-Json -Depth 5 | Out-File -FilePath $JsonFile -Encoding utf8
    LogLine "Wrote JSON output to $JsonFile"
} catch {
    LogLine "Failed to write JSON: $($_.Exception.Message)"
}

# Write summary log (human readable)
try {
    "System audit summary - $($Results.Metadata.CollectedAt)" | Out-File -FilePath $LogFile -Append
    "RequestsPerformed: $($Results.RequestsPerformed)" | Out-File -FilePath $LogFile -Append
    "" | Out-File -FilePath $LogFile -Append
    foreach ($k in $Results.Checks.Keys) {
        $c = $Results.Checks[$k]
        $line = "Check: $k - Success: $($c.Success) - Error: $($c.Error)"
        $line | Out-File -FilePath $LogFile -Append
    }
    LogLine "Human-readable log written to $LogFile"
} catch {
    Write-Host "Failed to write human log: $($_.Exception.Message)"
}

# Print summary on screen
Write-Host ""
Write-Host "Audit completed. RequestsPerformed: $($Results.RequestsPerformed)" -ForegroundColor Cyan
Write-Host "Log: $LogFile"
Write-Host "JSON: $JsonFile"